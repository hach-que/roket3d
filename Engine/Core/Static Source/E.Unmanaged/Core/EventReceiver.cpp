// This class handles all events that are generated by
// Irrlicht and physics engines.

#include "autobind/types.h"
#include "autobind/binding/lua.h"
#include "E.Unmanaged/Core/EventReceiver.h"

namespace Engine { namespace Unmanaged { namespace Core
{
    /* Method and constructor definitions */
    EventReceiver::EventReceiver(lua_State * L)
    {
		for (irr::u32 i = 0; i < irr::KEY_KEY_CODES_COUNT; ++i)
			this->m_PressedKeys[i] = false;
	}

    EventReceiver::~EventReceiver()
    {
		for (std::map<Engine::Unmanaged::Core::REvent *, function>::iterator i = this->m_Handlers.begin();
				i != this->m_Handlers.end(); i++)
		{
			// Reduce the reference count of the event by one.
			i->first->Drop();
		}
	}

	bool EventReceiver::OnEvent(const irr::SEvent& event)
	{
		// Ignore any non-keyboard events for the time being.
		if (event.EventType != irr::EET_KEY_INPUT_EVENT)
			return false;

		// Loop through all of the handlers and see if they
		// want to accept the event.
		bool handled = false;
		for (std::map<Engine::Unmanaged::Core::REvent *, function>::iterator i = this->m_Handlers.begin();
				i != this->m_Handlers.end(); i++)
		{
			if (i->first->AcceptEvent(event))
			{
				i->second.Call(i->first->GetArguments(event));
				handled = true;
			}
		}

		return handled;
	}

	bool EventReceiver::IsKeyDown(irr::EKEY_CODE key) const
    {
		return this->m_PressedKeys[key];
    }

	void EventReceiver::AddHandler(Engine::Unmanaged::Core::REvent * event, function handler)
	{
		// Make sure the event isn't freed.
		event->Grab();

		// Add the event.
		this->m_Handlers.insert(this->m_Handlers.end(),
			std::pair<Engine::Unmanaged::Core::REvent *, function>(event, handler)
			);
	}
}
} 
}


