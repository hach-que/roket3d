"Name"     = 'B++ (AutoBind)'
"Version"  = '1.0'
"Author"   = 'James Rhodes'
"About"    = 'Reads a C++ like syntax (B++) so that AutoBind can produce C++ code and header files'
"Start Symbol" = 

!* lex.charset *!
<hex-quad> ::= 
        <hexadecimal-digit> <hexadecimal-digit> <hexadecimal-digit> <hexadecimal-digit>
<universal-character-name> ::= 
        '\u' <hex-quad> | 
        '\U' <hex-quad> <hex-quad>

!* lex.pptoken *!
<preprocessing-token> ::=
        <header-name> | 
        <identifier> | 
        <pp-number> | 
        <character-literal> | 
        <user-defined-character-literal> | 
        <string-literal> | 
        <user-defined-string-literal> | 
        <preprocessing-op-or-punc>

!* lex.token *!
<token> ::=
        <identifier> |
        <keyword> |
        <literal> |
        <operator-token> |
        <punctator> |

!* lex.header *!
<header-name> ::= 
        '<' <h-char-sequence> '>' |
        '"' <q-char-sequence> '"'
<h-char-sequence> ::=
        {h-char} |
        <h-char-sequence> {h-char}
{h-char} = {Printable} - {LF} - '>'
<q-char-sequence> ::=
        {q-char} |
        <q-char-sequence> {q-char}
{q-char} = {Printable} - {LF} - '"'

!* lex.ppnumber *!
<pp-number> ::= 
        {digit} | 
        '.' {digit} | 
        <pp-number> {digit} | 
        <pp-number> <identifier-nondigit> | 
        <pp-number> 'e' <sign> | 
        <pp-number> 'E' <sign> | 
        <pp-number> '.'

!* lex.name *!
<identifier> ::=
        <identifier-nondigit> |
        <identifier> <identifier-nondigit> |
        <identifier> {digit}
<identifier-nondigit> ::=
        <nondigit> |
        <universal-character-name>
<nondigit> ::=
        <universal-character-name> |
        {nondigit-lex}
{nondigit-lex} = {Letter} + [_]
{digit} = {Number}

!* lex.key *!
<keyword> ::= 'alignof' | 'asm' | 'auto'
            | 'bool' | 'break'
            | 'case' | 'catch' | 'char' | 'char16_t' | 'char32_t'
            | 'class' | 'const' | 'constexpr' | 'const_cast'
            | 'continue'
            | 'decltype' | 'default' | 'delete' | 'do' | 'double'
            | 'dynamic_cast'
            | 'else' | 'enum' | 'explicit' | 'export' | 'extern'
            | 'false' | 'float' | 'for' | 'friend'
            | 'goto'
            | 'if' | 'inline' | 'int'
            | 'long'
            | 'mutable'
            | 'namespace' | 'new' | 'noexcept' | 'nullptr'
            | 'operator'
            | 'private' | 'protected' | 'public'
            | 'register' | 'reinterpret_cast' | 'return'
            | 'short' | 'signed' | 'sizeof' | 'static'
            | 'static_assert' | 'static_cast' | 'struct'
            | 'switch'
            | 'template' | 'this' | 'thread_local' | 'throw' | 'true'
            | 'try' | 'typedef' | 'typeid' | 'typename'
            | 'union' | 'unsigned' | 'using'
            | 'virtual' | 'void' | 'volatile'
            | 'wchar_t' | 'while'

!* lex.operators *!
<operator-token> ::= <preprocessing-op-or-punc>
<punctuator> ::= <preprocessing-op-or-punc>
<preprocessing-op-or-punc> ::=
        '{' | '}' | '[' | ']' | '#' | '##' | '(' | ')' | '<:' | ':>' |
        '<%' | '%>' | '%:' | '%:%:' | ';' | ':' | '...' | 'new' |
        'delete' | '?' | '::' | '.' | '.*' | '+' | '-' | '*' | '/' |
        '%' | '^' | '&' | '|' | '~' | '!' | '=' | '<' | '>' |
        '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '&=' | '|=' |
        '<<' | '>>' | '<<=' | '>>=' | '==' | '!=' | '<=' | '>=' |
        '&&' | '||' | '++' | '--' | ',' | '->*' | '->' | 'and' |
        'and_eq' | 'bitand' | 'bitor' | 'compl' | 'not' | 'not_eq' |
        'or' | 'or_eq' | 'xor' | 'xor_eq'

!* lex.literal.kinds *!
<literal> ::= 
        <integer-literal> |
        <character-literal> |
        <floating-literal> |
        <string-literal> |
        <boolean-literal> |
        <pointer-literal> |
        <user-defined-literal>

!* lex.icon *!
<integer-literal> ::=
        <decimal-literal> <integer-suffix>? |
        <octal-literal> <integer-suffix>? |
        <hexadecimal-literal> <integer-suffix>?
<decimal-literal> ::=
        <nonzero-digit> |
        <decimal-literal> <digit>
<octal-literal> ::=
        '0' |
        <octal-literal> <octal-digit>
<hexadecimal-literal> ::=
        '0x' <hexadecimal-digit> |
        '0X' <hexadecimal-digit> |
        <hexadecimal-literal> <hexadecimal-digit>
{nonzero-digit} = [123456789]
{octal-digit} = [01234567]
{hexadecimal-digit} = [0123456789abcdefABCDEF]
<integer-suffix> ::=
        {unsigned-suffix} {long-suffix}? |
        {unsigned-suffix} <long-long-suffix>? |
        {long-suffix} {unsigned-suffix}? |
        <long-long-suffix> {unsigned-suffix}?
{unsigned-suffix} = [uU]
{long-suffix} = [lL]
<long-long-suffix> ::= 'll' | 'LL'

!* lex.ccon *!
<character-literal> ::=
        "'" <c-char-sequence> "'" |
        "u" "'" <c-char-sequence> "'" |
        "U" "'" <c-char-sequence> "'" |
        "L" "'" <c-char-sequence> "'"
<c-char-sequence> ::=
        <c-char> |
        <c-char-sequence> <c-char>
<c-char> ::=
        {c-char-lex} |
        <escape-sequence> |
        <universal-character-name>
{c-char-lex} = {Printable} - {LF} - ['\]
<escape-sequence> ::=
        <simple-escape-sequence> |
        <octal-escape-sequence> |
        <hexadecimal-escape-sequence>
<simple-escape-sequence> ::=
        "\'" | '\"' | '\?' | '\\' | '\a' |
        '\b' | '\f' | '\n' | '\r' | '\t' |
        '\v'
<octal-escape-sequence> ::=
        '\' {octal-digit} |
        '\' {octal-digit} {octal-digit} |
        '\' {octal-digit} {octal-digit} {octal-digit}
<hexadecimal-escape-sequence> ::=
        '\x' {hexadecimal-digit} |
        <hexadecimal-escape-sequence> {hexadecimal-digit}

!* lex.fcon *!
